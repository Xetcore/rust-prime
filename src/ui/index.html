<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File Upload</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
    <style>
        body {
            padding: 20px;
        }
        #dropZone {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
            background-color: #f9f9f9;
        }
        #dropZone.dragover {
            border-color: #007bff;
            background-color: #e9f5ff;
        }
        .results-container h2, .results-container h3, .results-container h4 {
            margin-top: 1.5em;
        }
        .error-message {
            color: var(--pico-color-red-500, #d32f2f); /* Using Pico variable with fallback */
            border: 1px solid var(--pico-color-red-200, #ef9a9a);
            padding: 10px;
            border-radius: 4px;
            background-color: var(--pico-color-red-50, #ffebee);
        }
        .error-message ul {
            margin-bottom: 0;
        }
         .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s ease infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Modal Styles */
        /* The #tensorModal.modal class from Pico should handle basic modal layout.
           These styles ensure it's a full overlay and provide some content styling. */
        #tensorModal {
          position: fixed; /* Stay in place */
          z-index: 1000; /* Sit on top - Pico uses high z-indexes for modals too */
          left: 0;
          top: 0;
          width: 100%; /* Full width */
          height: 100%; /* Full height */
          overflow: auto; /* Enable scroll if needed for the modal itself */
          background-color: rgba(0,0,0,0.4); /* Black w/ opacity for backdrop */
          /* display: none; is handled by inline style initially and JS */
        }

        /* PicoCSS styles 'article' within '.modal' for the modal dialog box.
           We can adjust its default behavior if needed. */
        #tensorModal article {
          margin: 10% auto; /* More top margin for better centering */
          padding: 20px;   /* Default Pico padding might be sufficient, this ensures it */
          max-width: 700px; /* Increased max-width for potentially wider content */
          border-radius: 8px; /* Optional: ensure rounded corners if not default */
        }

        #tensorModal article header {
            display: flex; /* Allows aligning title and close button */
            justify-content: space-between;
            align-items: center;
        }

        #tensorModalContent h4 { /* Tensor Name */
          margin-top: 0; /* Remove default top margin if it's the first element */
          margin-bottom: 1rem;
          font-size: 1.5rem; /* Larger tensor name */
        }

        #tensorModalContent p {
          margin-bottom: 0.75rem; /* Consistent spacing for p tags */
          font-size: 1rem;
        }
        #tensorModalContent p strong {
            color: var(--pico-secondary-foreground); /* Use Pico variable for emphasis */
        }

        #tensorModalContent pre { /* For data preview */
          background-color: var(--pico-code-background); /* Use Pico variable */
          border: 1px solid var(--pico-form-field-border-color); /* Use Pico variable */
          padding: 15px; /* More padding */
          overflow-x: auto; /* Allow horizontal scroll for long previews */
          white-space: pre-wrap; /* Wrap lines but preserve formatting */
          word-wrap: break-word; /* Break long words if necessary */
          border-radius: 4px;
          max-height: 200px; /* Limit height and make scrollable if preview is very long */
          font-size: 0.9em;
        }

        /* Ensure close button is styled nicely by Pico.
           The .close class from Pico should handle most of it.
           We can add custom styles if needed for better positioning or appearance if it's not part of a <header>.
           Pico's default .close is typically for <dialog> or specific components.
           If the <a> tag with class "close" isn't styled as expected, we might need this: */
        #tensorModalCloseButton {
            text-decoration: none;
            font-size: 1.5rem; /* Make it a bit larger if needed */
            /* Pico's default .close styling might already be good. */
        }
    </style>
</head>
<body>
    <main class="container">
        <header>
            <h1>File Upload and Inspector</h1>
        </header>

        <div id="dropZone">
            <p>Drag and drop files here, or click to select files.</p>
        </div>

        <form id="uploadForm">
            <input type="file" id="fileInput" name="files" multiple>
            <button type="submit" id="uploadButton">Upload</button>
        </form>

        <div id="uploadResults" class="results-container" aria-live="polite">
            <!-- Server response will be displayed here -->
        </div>

        <!-- Placeholder for Tensor Details Modal -->
        <div id="tensorModal" class="modal" style="display:none;">
            <article>
                <header>
                    <!-- Added an ID for easier selection -->
                    <a href="#close" aria-label="Close" class="close" id="tensorModalCloseButton"></a>
                    Tensor Details
                </header>
                <div id="tensorModalContent">
                    <!-- Details will be populated here by JavaScript -->
                </div>
            </article>
        </div>
    </main>

    <script>
        // Get references to key DOM elements
        const uploadForm = document.getElementById('uploadForm');
        const fileInput = document.getElementById('fileInput'); // Hidden file input
        const dropZone = document.getElementById('dropZone');   // Visible drop zone area
        const responseDisplay = document.getElementById('uploadResults'); // Div to show server responses
        const uploadButton = document.getElementById('uploadButton'); // Submit button
        const tensorModal = document.getElementById('tensorModal'); // Modal element
        const tensorModalContent = document.getElementById('tensorModalContent'); // Modal content area
        const tensorModalCloseButton = document.getElementById('tensorModalCloseButton'); // Modal close button

        // --- Helper Functions ---
        function updateDropZoneText(files) {
            if (files && files.length > 0) {
                let fileNames = Array.from(files).map(file => file.name).join(', ');
                dropZone.innerHTML = `<p>Selected: ${fileNames}. Click Upload or drop more files.</p>`;
            } else {
                dropZone.innerHTML = `<p>Drag and drop files here, or click to select files.</p>`;
            }
        }

        // --- Drag and Drop Event Handlers ---
        function handleDropZoneClick() {
            fileInput.click();
        }

        function handleDragOver(event) {
            event.preventDefault(); // Necessary to allow dropping
            dropZone.classList.add('dragover'); // Add class for styling (e.g., border change)
        }

        function handleDragLeave() {
            dropZone.classList.remove('dragover');
        }

        function handleDrop(event) {
            event.preventDefault(); // Prevent default browser behavior (e.g., opening the file)
            dropZone.classList.remove('dragover'); // Remove visual feedback
            const files = event.dataTransfer.files; // Get the dropped files
            if (files.length) {
                fileInput.files = files; // Assign dropped files to the hidden file input
                updateDropZoneText(files); // Update UI text
            }
        }

        function handleFileInputChange() {
            updateDropZoneText(fileInput.files);
        }

        // Attach Drag and Drop Event Listeners
        dropZone.addEventListener('click', handleDropZoneClick);
        dropZone.addEventListener('dragover', handleDragOver);
        dropZone.addEventListener('dragleave', handleDragLeave);
        dropZone.addEventListener('drop', handleDrop);
        fileInput.addEventListener('change', handleFileInputChange);

        // --- Form Submission Handling ---
        async function handleFormSubmit(event) {
            event.preventDefault(); // Prevent traditional form submission

            // Client-side validation: Ensure at least one file is selected
            if (fileInput.files.length === 0) {
                responseDisplay.innerHTML = '<p class="error-message">Please select one or more files to upload.</p>';
                return;
            }

            // Create FormData object to send files
            const formData = new FormData();
            for (const file of fileInput.files) {
                formData.append('files', file); // "files" must match the name expected by the server
            }

            // --- Progress Indicators & UI State Changes ---
            // Display spinner and loading message
            responseDisplay.innerHTML = '<div class="spinner"></div><p>Uploading and processing...</p>';
            // Disable upload button to prevent multiple submissions
            uploadButton.disabled = true;
            uploadButton.setAttribute('aria-busy', 'true'); // For Pico.CSS loading state

            try {
                // Asynchronously send the form data to the /upload endpoint
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData, // FormData is correctly handled by fetch for multipart/form-data
                });

                // Get the server's response as HTML text
                const htmlData = await response.text();
                // Display the server's HTML response (could be success info or error details)
                responseDisplay.innerHTML = htmlData;

                // After response is inserted, make tensor items clickable
                attachTensorClickListeners();

                if (!response.ok) {
                    // Log a warning if the server response was not OK (e.g., 400, 500)
                    // The displayed `htmlData` should already contain the server-formatted error.
                    console.warn('Server responded with an error status:', response.status, response.statusText);
                }
            } catch (error) {
                // Handle network errors or other issues with the fetch request
                console.error('Error during upload:', error);
                responseDisplay.innerHTML = `<p class="error-message">An unexpected error occurred: ${error.message}. Check the console for more details.</p>`;
            } finally {
                // This block executes regardless of success or failure
                // Re-enable the upload button and remove loading state
                uploadButton.disabled = false;
                uploadButton.removeAttribute('aria-busy');
            }
        }
        uploadForm.addEventListener('submit', handleFormSubmit);

        // --- Tensor Click Handling ---
        function showTensorDetails(name, shape, dtype, preview) {
            // For now, just log the details.
            // In the next step, this will populate and show the modal.
            console.log("Tensor Clicked:");
            console.log("  Name:", name);
            console.log("  Shape:", shape);
            console.log("  DType:", dtype);
            console.log("  Preview:", preview);

            // Populate modal content
            tensorModalContent.innerHTML = `
                <h4>${name}</h4>
                <p><strong>Shape:</strong> ${shape}</p>
                <p><strong>Data Type:</strong> ${dtype}</p>
                <p><strong>Preview:</strong></p>
                <pre>${preview}</pre>
            `;
            // Display the modal
            tensorModal.style.display = 'block';
            // For PicoCSS, if using <dialog>, it would be: tensorModal.showModal(); or tensorModal.open = true;
            // Since it's a div styled as modal, direct style change is fine.
        }

        function attachTensorClickListeners() {
            const tensorListItems = responseDisplay.querySelectorAll('li[data-dtype]');
            tensorListItems.forEach(li => {
                // Make the tensor name part clickable by wrapping it, or making the whole li clickable
                // For simplicity, let's make the whole li clickable.
                li.style.cursor = 'pointer';
                li.addEventListener('click', function(event) {
                    event.preventDefault(); // If we wrap in <a> later

                    const name = this.textContent.split(':')[0].trim(); // Extract name from "Name: [shape]"
                    const shape = this.dataset.shape;
                    const dtype = this.dataset.dtype;
                    const preview = this.dataset.preview;

                    showTensorDetails(name, shape, dtype, preview);
                });
            });
        }

        // --- Modal Close Functionality ---
        tensorModalCloseButton.addEventListener('click', (event) => {
            event.preventDefault();
            tensorModal.style.display = 'none';
        });

        // Optional: Close modal if user clicks outside the modal content (on the backdrop)
        // This requires the .modal class to be a full-screen overlay for this to work effectively.
        // PicoCSS default modal might not behave like this out of the box if it's not a <dialog>.
        tensorModal.addEventListener('click', (event) => {
            if (event.target === tensorModal) { // Check if the click is directly on the modal backdrop
                tensorModal.style.display = 'none';
            }
        });

        // Optional: Close modal with Escape key
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && tensorModal.style.display === 'block') {
                tensorModal.style.display = 'none';
            }
        });
    </script>
</body>
</html>
