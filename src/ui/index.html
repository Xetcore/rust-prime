<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File Upload</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
    <style>
        body {
            padding: 20px;
        }
        #dropZone {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
            background-color: #f9f9f9;
        }
        #dropZone.dragover {
            border-color: #007bff;
            background-color: #e9f5ff;
        }
        .results-container h2, .results-container h3, .results-container h4 {
            margin-top: 1.5em;
        }
        .error-message {
            color: var(--pico-color-red-500, #d32f2f); /* Using Pico variable with fallback */
            border: 1px solid var(--pico-color-red-200, #ef9a9a);
            padding: 10px;
            border-radius: 4px;
            background-color: var(--pico-color-red-50, #ffebee);
        }
        .error-message ul {
            margin-bottom: 0;
        }
         .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s ease infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Modal Styles */
        #tensorModal, #comparisonModal, #tokenizerComparisonModal { /* Apply common modal styles */
          position: fixed;
          z-index: 1000;
          left: 0;
          top: 0;
          width: 100%;
          height: 100%;
          overflow: auto;
          background-color: rgba(0,0,0,0.4);
        }

        #tensorModal article, #comparisonModal article, #tokenizerComparisonModal article {
          margin: 10% auto;
          padding: 20px;
          border-radius: 8px;
        }
        #tensorModal article { max-width: 700px; }
        #comparisonModal article { max-width: 900px; }
        #tokenizerComparisonModal article { max-width: 800px; } /* Adjust as needed */

        #tensorModal article header, #comparisonModal article header, #tokenizerComparisonModal article header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #tensorModalContent h4 {
          margin-top: 0;
          margin-bottom: 1rem;
          font-size: 1.5rem;
        }

        #tensorModalContent p {
          margin-bottom: 0.75rem;
          font-size: 1rem;
        }
        #tensorModalContent p strong {
            color: var(--pico-secondary-foreground);
        }

        #tensorModalContent pre {
          background-color: var(--pico-code-background);
          border: 1px solid var(--pico-form-field-border-color);
          padding: 15px;
          overflow-x: auto;
          white-space: pre-wrap;
          word-wrap: break-word;
          border-radius: 4px;
          max-height: 200px;
          font-size: 0.9em;
        }

        #tensorModalCloseButton, #closeComparisonModalButton, #closeTokenizerComparisonModalButton {
            text-decoration: none;
            font-size: 1.5rem;
        }

        /* Comparison Modal Specific Styles */
        #comparisonGrid {
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: var(--pico-spacing, 1rem);
        }

        #tensorAComparisonArea, #tensorBComparisonArea {
            border: 1px solid var(--pico-form-field-border-color, #ddd);
            padding: var(--pico-spacing, 1rem);
            border-radius: var(--pico-border-radius, 0.25rem);
            background-color: var(--pico-card-background-color);
        }

        #tensorAComparisonArea h4, #tensorBComparisonArea h4, #comparisonResultArea h4,
        #tokenizerAInfo h4, #tokenizerBInfo h4, #tokenizerComparisonResults h5 { /* Added tokenizer modal headers */
            margin-top: 0;
            font-size: 1.2rem;
            border-bottom: 1px solid var(--pico-muted-border-color);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
        }
         #tokenizerComparisonResults h5 {
            font-size: 1.1rem; /* Slightly smaller for sub-sections */
         }


        #comparisonResultArea {
            margin-top: var(--pico-spacing, 1rem);
            padding: var(--pico-spacing, 1rem);
            border: 1px solid var(--pico-form-field-border-color, #ddd);
            border-radius: var(--pico-border-radius, 0.25rem);
            background-color: var(--pico-card-background-color);
        }

        #tensorAContent pre,
        #tensorBContent pre,
        #analysisContent pre {
          background-color: var(--pico-code-background, #f4f4f4);
          border: 1px solid var(--pico-form-field-border-color, #ddd);
          padding: 10px;
          overflow-x: auto;
          white-space: pre-wrap;
          word-wrap: break-word;
          max-height: 150px;
          font-size: 0.9em;
          border-radius: var(--pico-border-radius, 0.25rem);
        }

        /* Vocabulary Preview Styling */
        .vocab-preview-container {
            margin-top: 1rem;
            padding: 0.75rem;
            border: 1px solid var(--pico-muted-border-color);
            border-radius: var(--pico-border-radius);
            background-color: var(--pico-card-sectionning-background-color);
        }
        .vocab-preview-container h4 { /* Specifically target h4 in vocab preview */
            font-size: 1rem;
            margin-top: 0;
            margin-bottom: 0.5rem;
            border-bottom: none;
        }
        .vocab-preview-container ul {
            list-style-type: none;
            padding-left: 0;
            margin-bottom: 0;
            max-height: 180px;
            overflow-y: auto;
            font-size: 0.85em;
        }
        .vocab-preview-container ul li {
            padding: 0.15rem 0;
        }
        .vocab-preview-container ul li code {
            background-color: var(--pico-code-background);
            padding: 0.1em 0.3em;
            border-radius: var(--pico-border-radius);
        }

        /* Tokenizer Comparison Modal sections */
        .comparison-section {
            margin-bottom: 1rem;
            max-height: 200px; /* Example max height */
            overflow-y: auto;
        }
        .comparison-section ul {
            list-style-type: none;
            padding-left: 0;
        }
         .comparison-section li code {
            background-color: var(--pico-code-background);
            padding: 0.1em 0.3em;
            border-radius: var(--pico-border-radius);
        }
        .comparison-section mark { /* For ID conflicts */
            background-color: var(--pico-mark-background-color);
            color: var(--pico-mark-color);
            padding: 0.1em 0.2em;
        }

    </style>
</head>
<body>
    <main class="container">
        <header>
            <h1>File Upload and Inspector</h1>
        </header>

        <div id="dropZone">
            <p>Drag and drop files here, or click to select files.</p>
        </div>

        <form id="uploadForm">
            <input type="file" id="fileInput" name="files" multiple>
            <button type="submit" id="uploadButton">Upload</button>
        </form>

        <div id="uploadResults" class="results-container" aria-live="polite">
            <!-- Server response will be displayed here -->
        </div>

        <div id="compareButtonContainer" style="margin-top: 20px; text-align: center; display: none;">
             <button id="compareTensorsButton" role="button" disabled>Compare Selected Tensors (0)</button>
        </div>
        <div id="compareTokenizersButtonContainer" style="margin-top: 10px; text-align: center; display: none;">
            <button id="compareTokenizersButton" role="button" class="secondary" disabled>Compare Selected Tokenizers (0)</button>
        </div>

        <!-- Tensor Details Modal -->
        <div id="tensorModal" class="modal" style="display:none;">
            <article>
                <header>
                    <a href="#close" aria-label="Close" class="close" id="tensorModalCloseButton"></a>
                    Tensor Details
                </header>
                <div id="tensorModalContent">
                    <!-- Details will be populated here by JavaScript -->
                </div>
            </article>
        </div>

        <!-- Tensor Comparison Modal -->
        <div id="comparisonModal" class="modal" style="display:none;">
            <article>
                <header>
                    <a href="#close" aria-label="Close" class="close" id="closeComparisonModalButton"></a>
                    Tensor Comparison
                </header>
                <div id="comparisonGrid" class="grid">
                    <div id="tensorAComparisonArea">
                        <h4>Tensor A Details</h4>
                        <div id="tensorAContent"></div>
                    </div>
                    <div id="tensorBComparisonArea">
                        <h4>Tensor B Details</h4>
                        <div id="tensorBContent"></div>
                    </div>
                </div>
                <div id="comparisonResultArea" style="margin-top: 20px;">
                    <h4>Comparison Analysis</h4>
                    <div id="analysisContent"></div>
                </div>
            </article>
        </div>

        <!-- Tokenizer Comparison Modal -->
        <div id="tokenizerComparisonModal" class="modal" style="display:none;">
            <article>
                <header>
                    <a href="#close" aria-label="Close" class="close" id="closeTokenizerComparisonModalButton"></a>
                    Tokenizer Vocabulary Comparison
                </header>
                <div id="tokenizerAInfo"><h4>Tokenizer A: <span id="tokenizerAName"></span></h4><p>Vocabulary Size: <span id="tokenizerAVocabSize"></span></p></div>
                <hr>
                <div id="tokenizerBInfo" style="margin-top: 1rem;"><h4>Tokenizer B: <span id="tokenizerBName"></span></h4><p>Vocabulary Size: <span id="tokenizerBVocabSize"></span></p></div>
                <hr>
                <div id="tokenizerComparisonResults" style="margin-top: 1rem;">
                    <h5>Common Tokens (<span id="commonTokenCount">0</span>)</h5><div id="commonTokens" class="comparison-section"></div>
                    <h5>Unique to Tokenizer A (<span id="uniqueToACount">0</span>)</h5><div id="uniqueToA" class="comparison-section"></div>
                    <h5>Unique to Tokenizer B (<span id="uniqueToBCount">0</span>)</h5><div id="uniqueToB" class="comparison-section"></div>
                    <h5>ID Conflicts (<span id="idConflictCount">0</span>)</h5><div id="idConflicts" class="comparison-section"></div>
                </div>
            </article>
        </div>

    </main>

    <script>
        // Get references to key DOM elements
        const uploadForm = document.getElementById('uploadForm');
        const fileInput = document.getElementById('fileInput');
        const dropZone = document.getElementById('dropZone');
        const responseDisplay = document.getElementById('uploadResults');
        const uploadButton = document.getElementById('uploadButton');

        const tensorModal = document.getElementById('tensorModal');
        const tensorModalContent = document.getElementById('tensorModalContent');
        const tensorModalCloseButton = document.getElementById('tensorModalCloseButton');

        const compareTensorsButton = document.getElementById('compareTensorsButton');
        const compareButtonContainer = document.getElementById('compareButtonContainer');
        const compareTokenizersButton = document.getElementById('compareTokenizersButton');
        const compareTokenizersButtonContainer = document.getElementById('compareTokenizersButtonContainer');

        const tensorComparisonModal = document.getElementById('comparisonModal'); // Renamed for clarity
        const closeTensorComparisonModalButton = document.getElementById('closeComparisonModalButton'); // Renamed for clarity
        const tensorAContent = document.getElementById('tensorAContent');
        const tensorBContent = document.getElementById('tensorBContent');
        const analysisContent = document.getElementById('analysisContent');

        // Tokenizer Comparison Modal Elements
        const tokenizerComparisonModal = document.getElementById('tokenizerComparisonModal');
        const closeTokenizerComparisonModalButton = document.getElementById('closeTokenizerComparisonModalButton');
        const tokenizerAName = document.getElementById('tokenizerAName');
        const tokenizerAVocabSize = document.getElementById('tokenizerAVocabSize');
        const tokenizerBName = document.getElementById('tokenizerBName');
        const tokenizerBVocabSize = document.getElementById('tokenizerBVocabSize');
        const commonTokensDiv = document.getElementById('commonTokens');
        const commonTokenCountSpan = document.getElementById('commonTokenCount');
        const uniqueToADiv = document.getElementById('uniqueToA');
        const uniqueToACountSpan = document.getElementById('uniqueToACount');
        const uniqueToBDiv = document.getElementById('uniqueToB');
        const uniqueToBCountSpan = document.getElementById('uniqueToBCount');
        const idConflictsDiv = document.getElementById('idConflicts');
        const idConflictCountSpan = document.getElementById('idConflictCount');


        // --- Helper Functions ---
        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') {
                return String(unsafe); // Ensure it's a string before trying to replace
            }
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        }

        function updateDropZoneText(files) {
            if (files && files.length > 0) {
                let fileNames = Array.from(files).map(file => escapeHtml(file.name)).join(', ');
                dropZone.innerHTML = `<p>Selected: ${fileNames}. Click Upload or drop more files.</p>`;
            } else {
                dropZone.innerHTML = `<p>Drag and drop files here, or click to select files.</p>`;
            }
        }

        // --- Drag and Drop Event Handlers ---
        function handleDropZoneClick() { fileInput.click(); }
        function handleDragOver(event) { event.preventDefault(); dropZone.classList.add('dragover'); }
        function handleDragLeave() { dropZone.classList.remove('dragover'); }
        function handleDrop(event) {
            event.preventDefault();
            dropZone.classList.remove('dragover');
            const files = event.dataTransfer.files;
            if (files.length) {
                fileInput.files = files;
                updateDropZoneText(files);
            }
        }
        function handleFileInputChange() { updateDropZoneText(fileInput.files); }

        dropZone.addEventListener('click', handleDropZoneClick);
        dropZone.addEventListener('dragover', handleDragOver);
        dropZone.addEventListener('dragleave', handleDragLeave);
        dropZone.addEventListener('drop', handleDrop);
        fileInput.addEventListener('change', handleFileInputChange);

        // --- Form Submission Handling ---
        async function handleFormSubmit(event) {
            event.preventDefault();
            if (fileInput.files.length === 0) {
                responseDisplay.innerHTML = '<p class="error-message">Please select one or more files to upload.</p>';
                return;
            }
            const formData = new FormData();
            for (const file of fileInput.files) { formData.append('files', file); }

            responseDisplay.innerHTML = '<div class="spinner"></div><p>Uploading and processing...</p>';
            uploadButton.disabled = true;
            uploadButton.setAttribute('aria-busy', 'true');

            try {
                const response = await fetch('/upload', { method: 'POST', body: formData });
                const htmlData = await response.text();
                responseDisplay.innerHTML = htmlData;
                setupFileInteractions();
                if (!response.ok) {
                    console.warn('Server responded with an error status:', response.status, response.statusText);
                }
            } catch (error) {
                console.error('Error during upload:', error);
                responseDisplay.innerHTML = `<p class="error-message">An unexpected error occurred: ${error.message}. Check the console for more details.</p>`;
            } finally {
                uploadButton.disabled = false;
                uploadButton.removeAttribute('aria-busy');
            }
        }
        uploadForm.addEventListener('submit', handleFormSubmit);

        // --- Tensor Click Handling for Detail Modal ---
        function showTensorDetails(name, shape, dtype, preview) {
            tensorModalContent.innerHTML = `
                <h4>${escapeHtml(name)}</h4>
                <p><strong>Shape:</strong> ${escapeHtml(shape)}</p>
                <p><strong>Data Type:</strong> ${escapeHtml(dtype)}</p>
                <p><strong>Preview:</strong></p>
                <pre>${preview}</pre>
            `;
            tensorModal.style.display = 'block';
        }

        function attachTensorClickListeners() {
            const tensorListItems = responseDisplay.querySelectorAll('li[data-tensor-id]');
            tensorListItems.forEach(li => {
                li.style.cursor = 'pointer';
                li.addEventListener('click', function(event) {
                    if (event.target.name === 'tensor_compare_select') return;
                    event.preventDefault();
                    const nameElement = this.childNodes[1]; // Assuming checkbox is childNode[0], then text is childNode[1] or similar
                    const name = nameElement ? nameElement.textContent.split(':')[0].trim() : "Unknown";
                    showTensorDetails(name, this.dataset.shape, this.dataset.dtype, this.dataset.preview);
                });
            });
        }

        // --- Tensor Comparison Checkbox Logic ---
        function updateCompareTensorsButtonState() {
            const selectedCheckboxes = responseDisplay.querySelectorAll('input[name="tensor_compare_select"]:checked');
            const count = selectedCheckboxes.length;
            compareTensorsButton.textContent = `Compare Selected Tensors (${count})`;
            compareTensorsButton.disabled = count !== 2;
        }

        function attachTensorCheckboxListeners() {
            const checkboxes = responseDisplay.querySelectorAll('input[name="tensor_compare_select"]');
            if (checkboxes.length > 0) {
                compareButtonContainer.style.display = 'block';
            } else {
                compareButtonContainer.style.display = 'none';
            }
            checkboxes.forEach(checkbox => checkbox.addEventListener('change', updateCompareTensorsButtonState));
            updateCompareTensorsButtonState();
        }

        // --- Tokenizer Comparison Checkbox Logic ---
        function updateCompareTokenizersButtonState() {
            const selectedCheckboxes = responseDisplay.querySelectorAll('input[name="tokenizer_compare_select"]:checked');
            const count = selectedCheckboxes.length;
            compareTokenizersButton.textContent = `Compare Selected Tokenizers (${count})`;
            compareTokenizersButton.disabled = count !== 2;
        }

        function attachTokenizerCheckboxListeners() {
            const tokenizerPreElements = responseDisplay.querySelectorAll('pre[data-full-vocab-json]');
            let foundTokenizers = false;
            tokenizerPreElements.forEach(preElement => {
                foundTokenizers = true;
                const fileInfoContainer = preElement.parentElement; // Assuming <pre> is direct child of the block for a tokenizer
                let header = fileInfoContainer ? fileInfoContainer.querySelector('h3') : null;

                if (header && !header.querySelector('input[name="tokenizer_compare_select"]')) {
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.name = 'tokenizer_compare_select';
                    checkbox.value = header.textContent.trim();
                    checkbox.style.marginRight = '10px';
                    checkbox.style.verticalAlign = 'middle';

                    header.insertBefore(checkbox, header.firstChild);
                }
                 // Add change listener to ALL checkboxes of this type after potential creation
                const currentCheckboxes = fileInfoContainer.querySelectorAll('input[name="tokenizer_compare_select"]');
                currentCheckboxes.forEach(cb => {
                    // Remove existing listener to prevent duplicates if this function is called multiple times
                    // This is a simple way; a more robust way would be to mark elements that have listeners.
                    cb.removeEventListener('change', updateCompareTokenizersButtonState);
                    cb.addEventListener('change', updateCompareTokenizersButtonState);
                });

            });

            if (foundTokenizers) {
                compareTokenizersButtonContainer.style.display = 'block';
            } else {
                compareTokenizersButtonContainer.style.display = 'none';
            }
            updateCompareTokenizersButtonState();
        }

        // --- Vocabulary Preview Display ---
        function displayVocabularyPreviews() {
            const tokenizerPreElements = responseDisplay.querySelectorAll('pre[data-vocab-preview]');
            tokenizerPreElements.forEach(preElement => {
                if (preElement.nextElementSibling && preElement.nextElementSibling.classList.contains('vocab-preview-container')) {
                    return;
                }
                const vocabJsonString = preElement.dataset.vocabPreview;
                if (vocabJsonString) {
                    try {
                        const parsedVocab = JSON.parse(vocabJsonString);
                        if (Array.isArray(parsedVocab) && parsedVocab.length > 0) {
                            let vocabHtml = `<div class="vocab-preview-container"><h4>Vocabulary Preview (First ${parsedVocab.length} tokens):</h4><ul>`;
                            parsedVocab.forEach(item => {
                                if (Array.isArray(item) && item.length === 2) {
                                    vocabHtml += `<li>Token: <code>${escapeHtml(String(item[0]))}</code>, ID: ${item[1]}</li>`;
                                }
                            });
                            vocabHtml += '</ul></div>';
                            preElement.insertAdjacentHTML('afterend', vocabHtml);
                        }
                    } catch (error) {
                        console.error("Failed to parse vocab preview JSON:", error, "JSON string:", vocabJsonString);
                    }
                }
            });
        }

        // --- Setup all interactions after results are rendered ---
        function setupFileInteractions() {
            attachTensorClickListeners();
            attachTensorCheckboxListeners();
            attachTokenizerCheckboxListeners();
            displayVocabularyPreviews();
        }

        // --- Modal Close Functionality (Common for all modals) ---
        function closeModal(modalElement) {
            if (modalElement) modalElement.style.display = 'none';
        }

        tensorModalCloseButton.addEventListener('click', (event) => { event.preventDefault(); closeModal(tensorModal); });
        tensorModal.addEventListener('click', (event) => { if (event.target === tensorModal) closeModal(tensorModal); });

        closeTensorComparisonModalButton.addEventListener('click', (event) => { event.preventDefault(); closeModal(tensorComparisonModal); });
        tensorComparisonModal.addEventListener('click', (event) => { if (event.target === tensorComparisonModal) closeModal(tensorComparisonModal); });

        closeTokenizerComparisonModalButton.addEventListener('click', (event) => { event.preventDefault(); closeModal(tokenizerComparisonModal); });
        tokenizerComparisonModal.addEventListener('click', (event) => { if (event.target === tokenizerComparisonModal) closeModal(tokenizerComparisonModal); });


        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                if (tensorModal.style.display === 'block') closeModal(tensorModal);
                if (tensorComparisonModal.style.display === 'block') closeModal(tensorComparisonModal);
                if (tokenizerComparisonModal.style.display === 'block') closeModal(tokenizerComparisonModal);
            }
        });

        // --- Tensor Comparison Logic ---
        function parsePreviewString(previewStr) {
            if (!previewStr || typeof previewStr !== 'string') return [];
            let content = previewStr.replace(/^\[|\]$/g, '').replace(/,\s*\.\.\.$/, '');
            if (content === "") return [];
            return content.split(',').map(s => parseFloat(s.trim()));
        }

        function getTensorDataFromCheckbox(checkbox) {
            const parentLi = checkbox.closest('li[data-tensor-id]');
            if (!parentLi) return null;
            const tensorId = parentLi.dataset.tensorId;
            const parts = tensorId.split('::');
            const nameElement = parentLi.childNodes[1]; // Assuming checkbox is node 0, then text is node 1
            const name = nameElement ? nameElement.textContent.split(':')[0].trim() : (parts[1] || "Unknown");

            return {
                id: tensorId, name: name, filename: parts[0] || "Unknown File",
                shape: parentLi.dataset.shape, dtype: parentLi.dataset.dtype,
                preview: parentLi.dataset.preview,
                previewArray: parsePreviewString(parentLi.dataset.preview)
            };
        }

        compareTensorsButton.addEventListener('click', () => {
            const selectedCheckboxes = responseDisplay.querySelectorAll('input[name="tensor_compare_select"]:checked');
            if (selectedCheckboxes.length !== 2) { alert("Please select exactly two tensors to compare."); return; }
            const tensorAData = getTensorDataFromCheckbox(selectedCheckboxes[0]);
            const tensorBData = getTensorDataFromCheckbox(selectedCheckboxes[1]);
            if (!tensorAData || !tensorBData) { alert("Could not retrieve data for one or both selected tensors."); return; }

            tensorAContent.innerHTML = `
                <p><strong>Name:</strong> ${escapeHtml(tensorAData.name)}</p>
                <p><strong>File:</strong> ${escapeHtml(tensorAData.filename)}</p>
                <p><strong>Shape:</strong> ${escapeHtml(tensorAData.shape)}</p>
                <p><strong>Data Type:</strong> ${escapeHtml(tensorAData.dtype)}</p>
                <p><strong>Preview:</strong></p><pre>${tensorAData.preview}</pre>`;
            tensorBContent.innerHTML = `
                <p><strong>Name:</strong> ${escapeHtml(tensorBData.name)}</p>
                <p><strong>File:</strong> ${escapeHtml(tensorBData.filename)}</p>
                <p><strong>Shape:</strong> ${escapeHtml(tensorBData.shape)}</p>
                <p><strong>Data Type:</strong> ${escapeHtml(tensorBData.dtype)}</p>
                <p><strong>Preview:</strong></p><pre>${tensorBData.preview}</pre>`;

            let analysisHTML = "";
            if (tensorAData.shape !== tensorBData.shape) {
                analysisHTML += `<p class="error-message">Tensors have different shapes: ${escapeHtml(tensorAData.shape)} vs ${escapeHtml(tensorBData.shape)}.</p>`;
            }
            if (tensorAData.dtype !== tensorBData.dtype) {
                analysisHTML += `<p class="error-message">Tensors have different data types: ${escapeHtml(tensorAData.dtype)} vs ${escapeHtml(tensorBData.dtype)}.</p>`;
            }

            if (tensorAData.shape === tensorBData.shape && tensorAData.dtype === tensorBData.dtype) {
                analysisHTML += `<p>Tensors have compatible shapes and data types.</p>`;
                const previewA = tensorAData.previewArray; const previewB = tensorBData.previewArray;
                if (previewA.length > 0 && previewB.length > 0) {
                    let differences = [], maxLength = Math.max(previewA.length, previewB.length), previewsMatch = true;
                    let commonLength = Math.min(previewA.length, previewB.length);
                    for (let i = 0; i < commonLength; i++) {
                        differences.push((previewA[i] - previewB[i]).toPrecision(4));
                        if (Math.abs(previewA[i] - previewB[i]) > 1e-6) previewsMatch = false;
                    }
                    if (previewA.length !== previewB.length) {
                        previewsMatch = false;
                        for (let i = commonLength; i < maxLength; i++) differences.push('N/A');
                    }
                    analysisHTML += `<p><strong>Preview Differences (A - B):</strong> <pre>[${escapeHtml(differences.join(', '))}]</pre></p>`;
                    if (previewsMatch && !(tensorAData.preview.includes("...") || tensorBData.preview.includes("..."))) {
                         analysisHTML += `<p>Previews are numerically identical based on available data.</p>`;
                    } else if (tensorAData.preview.includes("...") || tensorBData.preview.includes("...")) {
                        analysisHTML += `<p>Note: Preview comparison is limited due to truncated data ("..."). Differences shown are for available elements.</p>`;
                    } else if (!previewsMatch) {
                        analysisHTML += `<p>Previews show numerical differences or have different lengths.</p>`;
                    }
                } else { analysisHTML += `<p>Preview data not available or empty for one or both tensors; cannot compare numerically.</p>`; }
            } else { analysisHTML += `<p>Cannot perform numerical comparison due to incompatible shapes or data types.</p>`; }

            analysisContent.innerHTML = analysisHTML;
            tensorComparisonModal.style.display = 'block'; // Ensure correct modal is shown
        });

        // --- Tokenizer Comparison Logic ---
        function displayTokenList(element, tokens, displayId = true, idFieldA = 'id', idFieldB = null) {
            let html = '';
            if (tokens.length > 0) {
                html += '<ul>';
                tokens.forEach(item => {
                    html += `<li><code>${escapeHtml(item.token)}</code>`;
                    if (displayId) {
                        html += ` (ID: ${item[idFieldA]}`;
                        if (idFieldB && item[idFieldB] !== undefined) {
                             html += `, ID B: ${item[idFieldB]}`;
                             if (item[idFieldA] !== item[idFieldB]) {
                                 html += ` <mark>Conflict!</mark>`;
                             }
                        }
                        html += `)`;
                    }
                    html += '</li>';
                });
                html += '</ul>';
            } else {
                html += '<p>None</p>';
            }
            element.innerHTML = html;
        }

        compareTokenizersButton.addEventListener('click', () => {
            const selectedCheckboxes = responseDisplay.querySelectorAll('input[name="tokenizer_compare_select"]:checked');
            if (selectedCheckboxes.length !== 2) {
                alert("Please select exactly two tokenizers to compare.");
                return;
            }

            const tokenizerData = [];
            selectedCheckboxes.forEach(cb => {
                let preElement = null;
                const h3 = cb.closest('h3');
                if (h3 && h3.parentElement) {
                    // Try to find the <pre> tag that is a sibling to the <h3> or within the same overall file block
                    let currentElement = h3.nextElementSibling;
                     while(currentElement) {
                        if (currentElement.tagName === 'PRE' && currentElement.dataset.fullVocabJson) {
                            preElement = currentElement;
                            break;
                        }
                        // Also check if it's wrapped in vocab-preview-container's sibling (if pre is first)
                        if (currentElement.classList && currentElement.classList.contains('vocab-preview-container')) {
                           let potentialPre = currentElement.previousElementSibling;
                           if(potentialPre && potentialPre.tagName === 'PRE' && potentialPre.dataset.fullVocabJson) {
                               preElement = potentialPre;
                               break;
                           }
                        }
                        currentElement = currentElement.nextElementSibling;
                    }
                     // If not found as a sibling, maybe it's a child of h3's parent, after h3
                    if (!preElement && h3.parentElement) {
                        let parentChildren = Array.from(h3.parentElement.children);
                        let h3Index = parentChildren.indexOf(h3);
                        for(let i = h3Index + 1; i < parentChildren.length; i++) {
                            if(parentChildren[i].tagName === 'PRE' && parentChildren[i].dataset.fullVocabJson) {
                                preElement = parentChildren[i];
                                break;
                            }
                        }
                    }
                }

                if (preElement && preElement.dataset.fullVocabJson) {
                    try {
                        const fullVocabMap = new Map(Object.entries(JSON.parse(preElement.dataset.fullVocabJson)));
                        tokenizerData.push({
                            name: cb.value,
                            vocab: fullVocabMap,
                            size: fullVocabMap.size
                        });
                    } catch (e) {
                        console.error("Failed to parse full_vocab_json for", cb.value, e);
                        tokenizerData.push({ name: cb.value, vocab: new Map(), size: 0, error: true });
                    }
                } else {
                     tokenizerData.push({ name: cb.value, vocab: new Map(), size: 0, error: true });
                     console.error("Could not find pre element with full_vocab_json for tokenizer:", cb.value);
                }
            });

            if (tokenizerData.some(d => d.error) || tokenizerData.length < 2) {
                alert("Could not retrieve vocabulary data for one or both selected tokenizers. Check console.");
                return;
            }

            const [dataA, dataB] = tokenizerData;

            tokenizerAName.textContent = escapeHtml(dataA.name);
            tokenizerAVocabSize.textContent = dataA.size;
            tokenizerBName.textContent = escapeHtml(dataB.name);
            tokenizerBVocabSize.textContent = dataB.size;

            const common = [];
            const uniqueA = [];
            const conflicts = [];

            dataA.vocab.forEach((idA, tokenA) => {
                if (dataB.vocab.has(tokenA)) {
                    const idB = dataB.vocab.get(tokenA);
                    common.push({ token: tokenA, idA: idA, idB: idB });
                    if (idA !== idB) {
                        conflicts.push({ token: tokenA, idA: idA, idB: idB });
                    }
                } else {
                    uniqueA.push({ token: tokenA, id: idA });
                }
            });

            const uniqueB = [];
            dataB.vocab.forEach((idB, tokenB) => {
                if (!dataA.vocab.has(tokenB)) {
                    uniqueB.push({ token: tokenB, id: idB });
                }
            });

            common.sort((x,y) => x.token.localeCompare(y.token));
            uniqueA.sort((x,y) => x.token.localeCompare(y.token));
            uniqueB.sort((x,y) => x.token.localeCompare(y.token));
            conflicts.sort((x,y) => x.token.localeCompare(y.token));

            commonTokenCountSpan.textContent = common.length;
            uniqueToACountSpan.textContent = uniqueA.length;
            uniqueToBCountSpan.textContent = uniqueB.length;
            idConflictCountSpan.textContent = conflicts.length;

            displayTokenList(commonTokensDiv, common, true, 'idA', 'idB');
            displayTokenList(uniqueToADiv, uniqueA);
            displayTokenList(uniqueToBDiv, uniqueB);
            displayTokenList(idConflictsDiv, conflicts, true, 'idA', 'idB');

            tokenizerComparisonModal.style.display = 'block';
        });
    </script>
</body>
</html>
